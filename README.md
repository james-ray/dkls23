# Implementation of DKLs23 and related code

The cates in this repository uses create sl-mpc-mate and sl-oblivious
from https://gitlab.com/com.silencelaboratories/sl-crypto

# Crates

## dkls23-rs

This is the core crate. The main functions are:

```rust
dkls23::keygen::dkg::run()

dkls23::sign::dsg::run()
```

## crates/msg-relay-svc

Driver of simple implmentation of a message relay service.

A few examples how to run it:

```shell
cargo run -p msg-relay-svc

# or, with some trace output
RUST_LOG=info cargo run -p msg-relay-svc

# and listen on more then one addr:port
cargo run -p msg-relay-svc -- \
  --listen 0.0.0.0:8080 \
  --peer ws://localhost:8081/v1/msg-replay
```
Option `--listen` understands IPv6 addresses.

Option `--peer` defines a peer instance. If the instance receives an ASK
message and there is no the corresponding ready message then forwards ASK
to all peers.

## crates/msg-relay

A reusable reference implementation of a message relay.
`msg-relay-svc` is built using this one.

## crates/msg-releay-client

This is client library to access message relay service.

An implementation of sl_mpc_mate::message::Relay trait.

## crates/dkls-party

This commad line utility to execute all steps of distributed
key generation (DKG) and distributed signature generation (DSG).

The simplest way to build and run it would be:

```shell
cargo run -p dkls-party -q --release -- --help
```

## crates/dkls-party/scripts/dkg.sh

This is a hleper script to generate all required keys, create
and initial message (setup message) and execute distributed
key generation and save result keyshares to files.

```shell
# create a directory for keyshares and various addtional files
mkdir ./data

# we assume that msg-relay-svc is running on this machine and
# it listens on 127.0.0.1:8080 (this is default)

# the following command will execute distributed key generation
#
# N=5 - number of participants
# T=3 - theshold
#
# show trace output as much as possible and place all data files
# into directory `./data`
#
RUST_LOG=debug DEST=./data ./crates/dkls-party/scripts/dkg.sh 5 3

# a last line of output pf dsg.sh will be public key of new key

# make sure there are keyshares

ls -l ./data/keyshare.*

```

## crates/dkls-party/dsg.sh

We generated key, now we are ready to genreate a signature

```shell
# we will use ./data directory populated by dkg.sh script

# This command will generate a signature for message "test"
# using first 3 keyshares
#
RUST_LOG=debug DEST=./data ./crates/dkls-party/scripts/dsg.sh "test" 0 1 2
```

Please, read comments in these scripts to get more details.

## Run example of full system.

### Build docker image

```shell
docker build -t dkls-party \
    --secret id=token,src=/path/to/file/containing/gitlab-token \
    .
```

This image contains `dkls-party` and `msg-relay-svc`

### Create keys

```shell
mkdir data
DEST=data ./crates/dkls-party/scripts/gen-keys.sh 3
```

This command will create set of keys for 3 node MPC network

### Start "all cloud nodes" MPC network

```shell
docker-compose up -d
```

This command will start set of services.

Three instances of "cloud nodes" with signing keys generated by
`gen-keys.sh`.  Also, the nodes will get a `setup verifying key` to
verify a setup message. More on this in the next steps. Each instance
represents a participant in an MPC network. In the actual system, one
node could be replaced by a load balancer and set (most likely
dynamic) of the computational node. We could scale our network.

Three instances of `msg-relay-svc`, one for each MPC network
participant.  Each computational node is configured to connect to its
instance of `msg-relay-svc.` Each message relay instance is configured
to connect to two others as its peer relay.

The last service is an instance of `msg-relay-svc` to receive setup
messages. It is a peer for all other message relay services, but all
other services are not peer for this instance.

### Generate distributed key

```shell
DEST=data ./crates/dkls-party/scripts/dkg-setup.sh 3 2
```

It will generate distributed key and print public key.

This command will generate a setup message for key generation and
send it (publish) to desigrated message relay instance.

Then it will contant all computation nodes and send them instance ID.
This is signal to start distributed key generation.

### Generate signature

```shell
DEST=./data ./crates/dkls-party/scripts/dsg-setup.sh 2 \
   <public key> \
   "message to sign" \
   0 1
```

The command above will generate signature.

## Configuration

The library uses two thread pools. One is controlled by variable
`RAYON_NUM_THREADS` and another one by `TOKIO_WORKER_THREADS`. Sum of
these numbers should match a number of CPU cores available for an
instance of a service.
